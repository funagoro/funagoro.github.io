<html>

<head></head>

<body>

<button id="dry">Unaffected</button>
<button id="wet">Effected</button>
<button id="combined">Combined</button>

<script>
//https://blog.gskinner.com/archives/2019/02/reverb-web-audio-api.html
//Matthew Willox

document.getElementById( "dry").addEventListener( "mousedown", function( e){ drySound.play();});
document.getElementById( "wet").addEventListener( "mousedown", function( e){ wetSound.play();});
document.getElementById( "combined").addEventListener( "mousedown", function( e){ combined.play();});

class Effect{
	constructor( context){
		this.context = context;
		this.input = this.context.createGain();
		this.effect = null;
		this.bypassed = false;
		this.output = this.context.createGain();
		this.setup();
		this.wireUp();
	}

	setup(){ this.effect = this.context.createGain();}

	wireUp(){
		this.input.connect( this.effect);
		this.effect.connect( this.output);
	}

	connect( destination){
		this.output.connect( destination);
	}
}

class Sample{
	constructor( context){
		this.context = context;
		this.buffer = this.context.createBufferSource();
		this.buffer.start();
		this.sampleBuffer = null
		this.rawBuffer = null;
		this.loaded = false;
		this.output = this.context.createGain();
		this.output.gain.value = 0.1;
	}

	play(){
		if( this.loaded){
			this.buffer = this.context.createBufferSource();
			this.buffer.buffer = this.sampleBuffer;
			this.buffer.connect( this.output);
			this.buffer.start( 0);
		}
	}

	connect( input){
		this.output.connect( input);
	}

	load( path){
		this.loaded = false;
		return fetch( path)
		.then( ( response) => response.arrayBuffer())
		.then( ( myBlob) => {
			return new Promise( ( resolve, reject) => {
				this.context.decodeAudioData( myBlob, resolve, reject);
			})
		})
		.then( ( buffer) => {
			this.sampleBuffer = buffer;
			this.loaded = true;
			return this;
		})
	}
}

class AmpEnvelope{
	constructor( context, gain = 1){
		this.context = context;
		this.output = this.context.createGain();
		this.output.gain.value = gain;
		this.partials = [];
		this.velocity = 0;
		this.gain = gain;
		this._attack = 0;
		this._sustain = this.output.gain.value;
		this._release = 0.001;
	}

	on( velocity){
		this.velocity = velocity / 127;

		this.output.gain.value = 0;
		this.output.gain.setValueAtTime( 0, 0);
		this.output.gain.setTargetAtTime( 1, 0, this.attack + 0.00001);
		this.output.gain.setTargetAtTime( this.sustain * this.velocity, this.attack, this.decay);
	}

	off(){
		this.sustain = this.output.gain.value;
		this.output.gain.cancelScheduledValues( 0);
		this.output.gain.setValueAtTime( this.sustain, 0);
		this.output.gain.setTargetAtTime( 0, 0, this.release + 0.00001);
	}

	set sustain( value){ this.gain = value;}
	get sustain(){ return this.gain;}

	connect( destination){ this.output.connect( destination);}
}

class Voice{
	constructor( context, type = "sawtooth", gain = 0.1){
		this.context = context;
		this.type = type;
		this.value = -1;
		this.gain = gain;
		this.output = this.context.createGain();
		this.partials = [];
		this.output.gain.value = this.gain;
		this.ae = new AmpEnvelope( this.context);
		this.ae.connect( this.output);
	}

	on( MidiEvent){
		this.value = MidiEvent.value;
		this.partials.forEach( ( osc) => {
			osc.frequency.value = MidiEvent.frequency;
		});
		this.ae.on( MidiEvent.velocity || MidiEvent);
	}

	off(){
		this.ae.off();
		this.partials.forEach( ( osc) => {
			osc.stop( this.context.currentTime + this.ae.release * 4);
		});
	}

	connect( destination){ this.output.connect( destination);}

	set attack( value){ this.ae.attack = value;}
	get attack(){ return this.ae.attack;}

	set decay( value){ this.ae.decay = value;}
	get decay(){ return this.ae.decay;}
/*
	set sustain( value){ this.ae.sustain = value;}
	get sustain(){ return this.ae.sustain;}
*/
	set release( value){ this.ae.release = value;}
	get release(){ return this.ae.release;}
}

class Noise extends Voice{
	constructor( context, gain){
		super( context, gain);
		this._length = 2;
	}

	get length(){ return this._length || 2;}
	set length( value){ this._length = value;}

	init(){
		let i, n;
		let r;

		r = this.context.sampleRate;
		n = this.length * r;
		let ab = this.context.createBuffer( 2, n, r);
		let d0 = ab.getChannelData( 0);
		let d1 = ab.getChannelData( 0);
		for( i = 0; i < n; i++){
			d0[ i] = 2 * Math.random() - 1;
			d1[ i] = 2 * Math.random() - 1;
		}

		let osc = this.context.createBufferSource();
		osc.buffer = ab;
		osc.loop = true;
		osc.loopStart = 0;
		osc.loopEnd = 2;
		osc.start( 0);
		osc.connect( this.ae.output);
console.log("pu");
		this.partials.push( osc);
	}

	on( MidiEvent){
		this.value = MidiEvent.value;
		this.ae.on( MidiEvent.velocity || MidiEvent);
	}
}

class Filter extends Effect{
	constructor( context, type = "lowpass", cutoff = 1000, resonance = 0.9){
		super( context);
		this.effect.frequency.value = cutoff;
		this.effect.Q.value = resonance;
		this.effect.type = type;
	}

	setup(){
		this.effect = this.context.createBiquadFilter();
		this.effect.connect( this.output);
		this.wireUp();
	}

}

class reverb extends Effect{
	constructor( context){
		super( context);
	}

	setup( reverbTime = 1, preDelay = 0.03){
		this.effect = this.context.createConvolver();

		this.reverbTime = reverbTime;

		this.attack = 0.001;
		this.decay = 0.1;
		this.release = reverbTime;

		this.preDelay = this.context.createDelay( reverbTime);
		this.preDelay.delayTime.setValueAtTime( preDelay, 0);

		this.multitap = [];

		for( let i = 2; i > 0; i--){
			this.multitap.push( this.context.createDelay( reverbTime));
		}
		this.multitap.map( ( t, i) => {
			if( this.multitap[ i + 1]) t.connect( this.multitap[ i + 1]);
			t.delayTime.setValueAtTime( 0.001 + ( i * ( preDelay / 2)), 0);
		});

		this.multitapGain = this.context.createGain();
		this.multitap[ this.multitap.length - 1].connect( this.multitapGain);
		this.multitapGain.gain.value = 0.2;
		this.multitapGain.connect( this.output);
		this.wet = this.context.createGain();
		this.input.connect( this.wet);
		this.wet.connect( this.preDelay);
		this.wet.connect( this.multitap[ 0]);
		this.preDelay.connect( this.effect);
		this.effect.connect( this.output);
	}

	renderTail(){
		let n;
		let r;

		r = this.context.sampleRate;
		n = this.reverbTime * r;

		const tailContext = new window.OfflineAudioContext( 2, n, r);
		tailContext.oncomplete = ( buffer) => {
			this.effect.buffer = buffer.renderedBuffer;
		}
		const tailOsc = new Noise( tailContext, 1);
		const tailLPFilter = new Filter( tailContext, "lowpass", 2000, 0.2);
		const tailHPFilter = new Filter( tailContext, "highpass", 500, 0.1);

		tailOsc.init();
		tailOsc.connect( tailHPFilter.input);
		tailHPFilter.connect( tailLPFilter.input);
		tailLPFilter.connect( tailContext.destination);
		tailOsc.attack = this.attack;
		tailOsc.decay = this.decay;
		tailOsc.release = this.release;

		tailContext.startRendering();

		tailOsc.on( { frequency : 500, velocity : 1});
		setTimeout( function(){ tailOsc.off();}, 20);
	}
}

let ac = new window.AudioContext;

let filter = new Filter( ac, "lowpass", 50000, 0.8);
filter.setup();

let verb = new reverb( ac); 
verb.setup( 20, 0.01);
verb.renderTail();
verb.wet.gain.value = 1;

let compressor = ac.createDynamicsCompressor();
compressor.threshold.setValueAtTime( -24, 0);
compressor.knee.setValueAtTime( 40, 0);
compressor.ratio.setValueAtTime( 12, 0);
compressor.attack.setValueAtTime( 0, 0);
compressor.release.setValueAtTime( 0.25, 0);
compressor.connect( ac.destination);

filter.connect( verb.input);
verb.connect( compressor);

let u = "https://mwmwmw.github.io/files/Instruments/DrumBeat.mp3";

let drySound = new Sample( ac);
drySound.load( u).then( function( s){
	drySound.connect( compressor);
});

let wetSound = new Sample( ac);
wetSound.load( u).then( function( s){
	wetSound.connect( filter.input);
});

let combined = new Sample( ac);
combined.load( u).then( function( s){
	combined.connect( filter.input);
	combined.connect( compressor);
});

</script>

</body>

</html>


<!DOCTYPE html>

<html lang="en">

<head>
	<meta charset="UTF-8" />
	<title>Oscillator | AudioWorklet samples</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, shrink-to-fit=no, viewport-fit=cover" />
</head>

<body>

<section>

	<h1>Oscillator</h1>

	<form>
		<label><input type="radio" name="wt" value="sine" checked /> SINE</label>
		<label><input type="radio" name="wt" value="square" /> SQUARE</label>
		<label><input type="radio" name="wt" value="sawtooth" /> SAWTOOTH</label>
		<label><input type="radio" name="wt" value="triangle" /> TRIANGLE</label>
	</form>

	<div>
		<label><input type="range" value="440" min="20" max="4000" step="1" /> FREQUENCY</label>
		<button type="button">START</button>
	</div>

</section>

<br><br><br>

<button type="button" id="button_taiko">taiko</button>



<script>

'use strict';

//let ac;
//if( window.AudioContext) ac = new window.AudioContext();
//else ac = new window.webkitAudioContext();
const ac = new window.AudioContext();

let is_muted = false;

//const promise = ac.audioWorklet.addModule( "oscillator_w.js?3");
//const promise = ac.audioWorklet.addModule( "data:text/javascript," + encodeURI( `
ac.audioWorklet.addModule( "data:text/javascript," + encodeURI( `

	'use strict';

	class awp extends AudioWorkletProcessor{
		static get parameterDescriptors(){
			return [ {
				name : "frequency",
				defaultValue : 440,
				minValue : 20,
				maxValue : sampleRate / 2,
				automationRate : "a-rate"
			}];
		}

		constructor(){
			super();

//this.port.postMessage( "123");
//this.port.postMessage( ": "+sampleRate); //48000
//this.port.postMessage( ": "+frequency); //なし

			this.type = "sine";
			this.n = 0;
			this.port.onmessage = ( e) => {
				if( e.data == "ping"){
					this.port.postMessage( "pong");
					//console.log( e.data);
				} else{
					this.type = e.data;
				}
			};
		}

		process( inputs, outputs, parameters){
			let i, n;

			const output = outputs[ 0];

			const numberOfChannels = output.length;

			for( let channel = 0; channel < numberOfChannels; channel++){
				const outputChannel = output[ channel];

				n = outputChannel.length;
				for( i = 0; i < n; i++){
					const frequency = parameters.frequency.length > 1 ? parameters.frequency[ i] : parameters.frequency[ 0];
					const t = sampleRate / frequency;

					let a;

					switch( this.type){
					case "sine":
						a = 0.3*Math.sin( 2 * Math.PI * frequency * this.n / sampleRate);
						break;

					case "square":
						a = ( this.n < t / 2) ? 1 : -1;
						break;

					case "sawtooth":
						a = 2 * this.n / t - 1;
						break;

					case "triangle":
						a = 4 * this.n / t;
						a = ( this.n < t / 2) ? a - 1 : 3 - a;
						break;

					}

					outputChannel[ i] = a;

					if( t <= ++this.n) this.n = 0;
				}
			}

			return true;
		}
	}

	registerProcessor( "o1", awp);

`)).then( function(){
	const awnode = new AudioWorkletNode( ac, "o1");

	//setInterval( () => o.port.postMessage( "ping"), 1000);
	awnode.port.onmessage = ( e) => console.log( e.data);

	document.querySelector( 'button').addEventListener( "click", async ( event) => {
		if( ac.state !== "running") await ac.resume();

		const b = event.target;

		if( b.textContent === "START"){
			awnode.connect( ac.destination);
			b.textContent = "STOP";
		} else {
			awnode.disconnect( 0);
			b.textContent = "START";
		}
	}, false);

	document.addEventListener( "visibilitychange", function(){
		let s;

		s = document.visibilityState;
		if( s == "hidden"){
			ac.suspend();
			is_muted = true;
			//dv.style.visibility = "visible";
		} else if( s == "visible"){
			//★ 何もしない。
			ac.resume();
		}
	}, false);

	document.querySelector( "form").addEventListener( "change", ( event) => {
		let i, n;

		const form = event.currentTarget;

		n = form.elements[ "wt"].length;
		for( i = 0; i < n; i++){
			if( form.elements[ "wt"][ i].checked){
				const type = form.elements[ "wt"][ i].value;
				awnode.port.postMessage( type);
				break;
			}
		}
	}, false);

	document.querySelector( '[ type = "range"]').addEventListener( "change", ( event) => {
		const f = event.currentTarget.valueAsNumber;
		const t = ac.currentTime;
		const p = awnode.parameters.get( "frequency");

		//p.setValueAtTime( p.value, t);
		p.linearRampToValueAtTime( f, t + 0.5);
	}, false);

}).catch( console.error);

let i, n, rate;
let t, w;
let d;
let ab_taiko, gn_taiko, absnode;

rate = ac.sampleRate;

n = 2 * rate;
ab_taiko = ac.createBuffer( 1, n, rate); //★ チャンネル数、サンプル数、レート。
d = ab_taiko.getChannelData( 0);
for( i = 0; i < n; i++){
	t = 0.7 * i / rate;
	t = Math.sqrt( t * 5) / 5;
	w = Math.max( -1, Math.min( 1,
		4 * Math.sin( 6.28318 * 100 * t)
	)) * Math.exp( -10 * Math.max( t - 0.15, 0));
	w += 3 * Math.exp( -15 * t);
	d[ i] = 2 * w;
}
gn_taiko = ac.createGain();
gn_taiko.gain.value = 0.18;
gn_taiko.connect( ac.destination);

document.getElementById( "button_taiko").addEventListener( "click", function( e){
	absnode = ac.createBufferSource();
	absnode.buffer = ab_taiko;
	absnode.connect( gn_taiko);
	absnode.start();
});

</script>

</body>

</html>

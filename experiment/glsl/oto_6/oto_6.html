
<!DOCTYPE html>

<html lang="ja">

<head>

<meta charset="utf-8">

<title>oto 6 - MONKEY CIRCUS おさるサーカス</title>
<meta property="og:title" content="oto 6 - MONKEY CIRCUS おさるサーカス">
<meta property="og:url" content="https://funagoro.github.io/experiment/glsl/oto_6.html">
<meta property="og:type" content="website">
<meta property="og:image" content="https://funagoro.github.io/experiment/glsl/oto_6_t.jpg">
<link rel="apple-touch-icon" href="https://funagoro.github.io/experiment/glsl/oto_6_t.jpg">
<meta name="apple-mobile-web-app-title" content="oto 6">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="description" content="AudioWorklet experiment and GLSL WebGL">

<link rel="shortcut icon" href="favicon.ico" />
<link rel="stylesheet" type="text/css" href="glsl.css" />

<meta name="viewport" content="width=600">
<style> @viewport { width : 600px;} </style>

</head>

<body>



<div class="t"></div>



<canvas id="canvas1" style="width : 512px; height : 512px;"></canvas><br>
<br>
<span class="title">"oto 6"</span><br>
&copy;2022 Maeda Mameo<br>



<div class="b"></div>



<script src="skeleton_touch.js"></script>

<script src="three_130_min.js"></script>

<script>

'use strict';

const W = 512;

let my_state;
const STATE_DEFAULT = 0, STATE_WORKING = 1, STATE_MUTED = 2;
my_state = STATE_DEFAULT;

const can = document.getElementById( "canvas1");
	can.width = can.height = W;

const ren = new THREE.WebGLRenderer( { canvas : can});

const cam = new THREE.PerspectiveCamera( 40, 1 / 1, 0.1, 100);
	cam.position.set( 0, 0, 5);
	cam.lookAt( 0, 0, 0);

const scene = new THREE.Scene();
scene.background = new THREE.Color( "white");

const o_touch = new THREE.Mesh(
	new THREE.PlaneGeometry( 1, 1),
	new THREE.MeshBasicMaterial( { color: 0xcccccc})
);
o_touch.rotation.set( -1.57079, 0, 0);
o_touch.rotation.set( 0, 0, 0);
//o_touch.receiveShadow = true;
scene.add( o_touch);

//◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍

let ac;
let awnode;
let ab_taiko, gn_taiko, absnode;

//★ skeleton_touch.js のための設定。
const REFW = W, REFH = W, MAXTOUCH = 5, CAN_PINCH = false;
function touch_event_hook(){

	if( skt.num == 1 && skt.x == skt.bx && skt.y == skt.by){
		//★ シングルタッチでかつ、動いていないタッチに限る。

		//if( my_state == STATE_WAIT_FOR_TOUCH){
			//if( ac.state !== "running") await ac.resume();

			//const b = event.target;

			if( my_state == STATE_DEFAULT){
				ac = new window.AudioContext();
				ac.audioWorklet.addModule( "data:text/javascript," + encodeURI( `

					'use strict';

					class awp extends AudioWorkletProcessor{
						static get parameterDescriptors(){
							return [ {
								name : "frequency",
								defaultValue : 440,
								minValue : 20,
								maxValue : sampleRate / 2,
								automationRate : "a-rate"
							}];
						}

						constructor(){
							super();

				//this.port.postMessage( "123");
				//this.port.postMessage( ": "+sampleRate); //48000
				//this.port.postMessage( ": "+frequency); //なし

							this.type = "sine";
							this.n = 0;
							this.port.onmessage = ( e) => {
								if( e.data == "ping"){
									this.port.postMessage( "pong");
									//console.log( e.data);
								} else{
									this.type = e.data;
								}
							};
						}

						process( inputs, outputs, parameters){
							let i, n;

							const output = outputs[ 0];

							const numberOfChannels = output.length;

				//this.port.postMessage( "n"+numberOfChannels);
							for( let channel = 0; channel < numberOfChannels; channel++){
								const outputChannel = output[ channel];

								n = outputChannel.length;
								for( i = 0; i < n; i++){
									const frequency = parameters.frequency.length > 1 ? parameters.frequency[ i] : parameters.frequency[ 0];
									const t = sampleRate / frequency;

									let a;

									switch( this.type){
									case "sine":
										a = 0.3*Math.sin( 2 * Math.PI * frequency * this.n / sampleRate);
										break;

									case "square":
										a = ( this.n < t / 2) ? 1 : -1;
										break;

									case "sawtooth":
										a = 2 * this.n / t - 1;
										break;

									case "triangle":
										a = 4 * this.n / t;
										a = ( this.n < t / 2) ? a - 1 : 3 - a;
										break;

									}

									outputChannel[ i] = a;

									if( t <= ++this.n) this.n = 0;
								}
							}

							return true;
						}
					}

					registerProcessor( "o1", awp);

				`)).then( function(){
					awnode = new AudioWorkletNode( ac, "o1");

					//setInterval( () => o.port.postMessage( "ping"), 1000);
					awnode.port.onmessage = ( e) => console.log( e.data);

					document.addEventListener( "visibilitychange", function(){
						let s;

						s = document.visibilityState;
						if( s == "hidden"){
							ac.suspend();
							my_state = STATE_MUTED;
							//dv.style.visibility = "visible";
							o_touch.visible = true;
						} else if( s == "visible"){
							//★ 何もしない。
							//ac.resume();
						}
					}, false);

let i, n, rate;
let t, w;
let d;

rate = ac.sampleRate;

n = 2 * rate;
ab_taiko = ac.createBuffer( 1, n, rate); //★ チャンネル数、サンプル数、レート。
d = ab_taiko.getChannelData( 0);
for( i = 0; i < n; i++){
	t = 0.7 * i / rate;
	t = Math.sqrt( t * 5) / 5;
	w = Math.max( -1, Math.min( 1,
		4 * Math.sin( 6.28318 * 100 * t)
	)) * Math.exp( -10 * Math.max( t - 0.15, 0));
	w += 3 * Math.exp( -15 * t);
	d[ i] = 2 * w;
}
gn_taiko = ac.createGain();
gn_taiko.gain.value = 0.18;
gn_taiko.connect( ac.destination);

				awnode.connect( ac.destination);
				//b.textContent = "STOP";
				my_state = STATE_WORKING;
				o_touch.visible = false;

				}).catch( console.error);

			} else if( my_state == STATE_MUTED){
				//awnode.disconnect( 0);
				//b.textContent = "START";

				ac.resume();
				my_state = STATE_WORKING;
				//dv.style.visibility = "hidden";
				o_touch.visible = false;
			}
	}
}
const skt = new skeleton_touch( can);
skt.set_mag_and_orientation( 1, 0);

//◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍

let count = 0;

tic();

function tic(){
	let i;
	let t;

	requestAnimationFrame( tic);

	skt.pre();

	if( my_state == STATE_WORKING){
		if( skt.start){
console.log("don");
			absnode = ac.createBufferSource();
			absnode.buffer = ab_taiko;
			absnode.connect( gn_taiko);
			absnode.start();
		}
	}

	ren.render( scene, cam);

	skt.post();

	count++;
}
</script>

</body>

</html>

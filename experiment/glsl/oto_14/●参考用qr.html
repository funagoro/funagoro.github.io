<!DOCTYPE html>
<html lang="ja">

<head>

<meta charset="utf-8">

<title>qr - MONKEY CIRCUS おさるサーカス</title>

<link rel="shortcut icon" href="favicon.ico"/>
<link rel="stylesheet" type="text/css" href="glsl.css" />

<meta name="viewport" content="width=700">
<style> @viewport { width : 700px;} </style>

</head>

<body>



<div class="t"></div>



<canvas id="canvas_1" style="
	width: 512px; height: 512px;
	user-select: none;
	-webkit-tap-highlight-color: rgba( 0, 0, 0, 0);
	touch-action: none;
"></canvas><br>
touch and draw<br>
<br>
<span class="title">"qr"</span><br>
&copy;2021 Maeda Mameo<br>



<div class="b"></div>



<script src="skeleton_touch_2.js"></script>

<script src="three_130_min.js"></script>

<script>

const D = 32; //★ 一辺のドット数。64 や 128 に変えてもいい。

const W = 512; //★ 画面全体のオフスクリーンテクスチャのサイズ。

const VS = `
	varying vec2 v;

	void main(){
		v = uv;
		gl_Position = projectionMatrix * modelViewMatrix * vec4( position.x, position.y, 0.0, 1.0);
	}
`;

//◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍

const G = 255;
var i, j, p;
var t;
var o; //★ 3D オブジェクト汎用。

//★ z 座標、ストライドをいろいろ変えても、割りきれるように、振り幅を 240 にしている。
//★ 0 : 不動。 1〜241 の奇数 : 減っていって 1 に貼り付く。
//★ 2〜242 の偶数 : 増えていって 242 に貼り付く。 243 : 不動。
const dat = new Uint8Array( 16 * D * D);
p = 0;
for( i = 0; i < D; i++) for( j = 0; j < D; j++){
	//★ 回転・拡大なしの、位置指定だけの Matrix4。
	dat[ p++] = 1; dat[ p++] = 0; dat[ p++] = 0; dat[ p++] = 0;
	dat[ p++] = 0; dat[ p++] = 1; dat[ p++] = 0; dat[ p++] = 0;
	dat[ p++] = 0; dat[ p++] = 0; dat[ p++] = 1; dat[ p++] = 0;
	dat[ p++] = ( 0.5 + j) / D * 256;
	dat[ p++] = ( 0.5 + i) / D * 256;
	dat[ p++] = 1;// + 241 * Math.floor( 2 * Math.random());
	dat[ p++] = 1;
}
for( i = 0; i < D / 4; i++) for( j = 0; j < D / 4; j++){
	p = Math.floor( Math.max(
		Math.abs( i + 0.5 - D / 32 * 3.5),
		Math.abs( j + 0.5 - D / 32 * 3.5)
	) / D * 32 + 0.5);
	t = ( p == 4 || p == 2) ? 0 : 243;
	dat[ 16 * ( ( D - 1 - i) * D + j) + 14] = t;
	dat[ 16 * ( ( D - 1 - i) * D + D - 1 - j) + 14] = t;
	dat[ 16 * ( i * D + j) + 14] = t;
}

const rt_1 = new THREE.WebGLRenderTarget( 2 * D, 2 * D);
o = rt_1.texture;
o.magFilter = o.minFilter = THREE.NearestFilter;

const rt_2 = new THREE.WebGLRenderTarget( 2 * D, 2 * D);
o = rt_2.texture;
o.magFilter = o.minFilter = THREE.NearestFilter;

const dat_tex = new THREE.DataTexture( dat, 2 * D, 2 * D, THREE.RGBAFormat);
const mat_c = new THREE.ShaderMaterial( {
	uniforms: {
		d: { value: D},
		tex: { value: dat_tex}
	},
	vertexShader: VS,
	fragmentShader: `
		uniform float d;
		uniform sampler2D tex;

		varying vec2 v;

		const float G = 255.0;
		const float T = 0.25;

		float ox( float dx, float dy){
			float p;

			p = floor( 2.0 * v.x * d / 4.0) + 0.5 * d * floor( 2.0 * v.y * d);
			p = mod( mod( p, d) + dx + d, d) + d * mod( floor( p / d) + dy + d, d);
			return ( texture2D( tex, vec2(
				( 4.0 * mod( p, 0.5 * d) + 3.0) / 2.0 / d,
				floor( p / 0.5 / d) / 2.0 / d
			)).z < T) ? 0.0 : 1.0;
		}

		void main(){
			float a, b;
			vec4 c;

			c = texture2D( tex, v);
			if( mod( floor( 2.0 * v.x * d), 4.0) == 3.0){
				if( 0.0 < c.z && c.z < 243.0 / G){
					a = floor( c.z * G + 0.5);
					if( a == 1.0 || a == 242.0){
						b = ox( -1.0, -1.0) + ox( 0.0, -1.0) + ox( 1.0, -1.0) +
							ox( -1.0, 0.0) + ox( 1.0, 0.0) +
							ox( -1.0, 1.0) + ox( 0.0, 1.0) + ox( 1.0, 1.0);
						if( a == 1.0){ if( b == 3.0) c.z = 2.0 / G;}
						else{ if( b < 2.0 || 3.0 < b) c.z = 241.0 / G;}
					}
				}
			}
			gl_FragColor = c;
		}
	`
});

const mat_p = new THREE.ShaderMaterial( {
	uniforms: {
		d: { value: D},
		p: { value: 0.0},
		tex: { value: dat_tex}
	},
	vertexShader: VS,
	fragmentShader: `
		uniform float d, p;
		uniform sampler2D tex;

		varying vec2 v;

		const float G = 255.0;

		void main(){
			float a;
			vec4 c;

			c = texture2D( tex, v);
			if( mod( floor( 2.0 * v.x * d), 4.0) == 3.0){
				if( 0.0 < c.z && c.z < 243.0 / G){
					if( abs( floor( 0.5 * v.x * d) + 0.5 * d * floor( 2.0 * v.y * d) - p) < 2.0)
						c.z = 2.0 / G;
					else{
						a = floor( c.z * G + 0.5);
						if( 1.0 < a && a < 242.0){
							if( 0.5 < mod( a, 2.0)) a -= 16.0; else a += 16.0;
							c.z = a / G;
						}
					}
				}
			}
			gl_FragColor = c;
		}
	`
});

//◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍

const can = document.getElementById( "canvas_1");
can.width = can.height = W;

const ren = new THREE.WebGLRenderer( { canvas: can});
ren.autoClear = false;

const scene_o = new THREE.Scene();

const plane_o = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2), mat_c);
scene_o.add( plane_o);

const cam_o = new THREE.OrthographicCamera( -1, 1, 1, -1, -1, 1);

const scene = new THREE.Scene();
scene.background = new THREE.Color( 0xffffff);

const plane = new THREE.Mesh(
	new THREE.PlaneGeometry( 10, 10),
	new THREE.MeshBasicMaterial({ color : 0xffffff, transparent : true})
);
scene.add( plane);

for( i = 0; i <= D; i++){
	o = new THREE.Mesh(
		new THREE.PlaneGeometry( 0.003, 2.003).translate( -1 + 2 * i / D, 0, -2 / D),
		new THREE.MeshBasicMaterial({ color : 0xff0000})
	);
	scene.add( o);
	o = o.clone();
	o.rotation.z = 1.57079;
	scene.add( o);
}

o = new THREE.DirectionalLight( 0xffffff, 1);
o.position.set( 2, -1, 1);
scene.add( o);

const cam = new THREE.PerspectiveCamera( 40, 1 / 1, 0.1, 1000);

ren.setRenderTarget( rt_1);
ren.render( scene_o, cam_o);

const bits = new THREE.InstancedMesh(
	new THREE.PlaneGeometry(),
	new THREE.MeshPhongMaterial( { color : 0x666666, flatShading : true, shininess : 150}),
	D * D
);
t = 2 / 256;
bits.scale.set( t, t, t / D * 4);
bits.position.set( -1, -1, -243 / 256 / D * 8);
scene.add( bits);

//◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍

//★ skeleton_touch.js のための設定。
const REFW = REFH = 512, MAXTOUCH = 5, CAN_PINCH = false;
const skt = new skeleton_touch( can);
skt.set_mag_and_orientation( 1, 0);

//◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍

var count = 0;
var candy = 0; //★ ニョキニョキが終わるまでカウントダウン。

//bits.geometry = s.scene.children[ 0].geometry.rotateX( 1.57079).scale( 130 / D, 130 / D, 32);
bits.geometry = new THREE.BoxGeometry( 8, 8, 200);
//bits.geometry.computeVertexNormals();

tic();

function tic(){
	var r, t, u;

	requestAnimationFrame( tic);

	skt.pre();

	if( count % 2 < 1){ a = rt_1; b = rt_2;} else { a = rt_2; b = rt_1;}

	if( skt.on){
		t = skt.x / 512 * D + Math.floor( ( 1 - skt.y / 512) * D) * D;
	} else if( count % 777 < 100){
		t = Math.random() * D * D;
	} else if( candy == 0){
		t = 100000;
	} else t = -7;

	if( t < 0) candy--; else candy = 18;
	if( t < 100000){
		mat_p.uniforms.p.value = Math.floor( t);
		mat_p.uniforms.tex.value = a.texture;
		plane_o.material = mat_p;
	} else{
		mat_c.uniforms.tex.value = a.texture;
		plane_o.material = mat_c;
	}
	ren.setRenderTarget( b);
	ren.render( scene_o, cam_o);

	ren.readRenderTargetPixels( b, 0, 0, 2 * D, 2 * D, dat);
	//★ Uint8Array を Float32Array にコピー。
	//★ 4 要素が 1 要素になる訳ではなく、0〜255 の整数が Float32 に入る。
	//★ 1 ピクセル 4 バイトなので、4 ピクセルで 1 つの Matrix4 を構成する。
	bits.instanceMatrix.array.set( dat);
	bits.instanceMatrix.needsUpdate = true;

	t = count / 1000 % 1;
	u = 0.5 - 0.5 * Math.cos( 6.28318 * t);
	plane.material.opacity = 1 - u * u;
	r = 1 + Math.cos( 8 * t % 2 * 3.14159);
	r = Math.tan( 1.57079 * ( 0.9995 - 0.007 * u * r * r));
	cam.setFocalLength( r);
	t = 0.5 * Math.floor( t / 0.5) + 0.25 * ( 1 - Math.cos( t % 0.5 * 2 * 3.14159));
	t *= 6.28318;
	cam.position.set(
		0.02 * r * ( Math.sin( t)),
		0.02 * r * ( Math.cos( t) - 1),
		0.06 * r * ( 0.6 + 0.4 * Math.cos( t))
	);
	cam.lookAt( 0, 0, 0);

	ren.setRenderTarget( null);
	ren.render( scene, cam);

	skt.post();

	count++;
}

</script>

</body>

</html>

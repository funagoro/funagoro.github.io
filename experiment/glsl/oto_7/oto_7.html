
<!DOCTYPE html>

<html lang="ja" style="-webkit-user-select : none; user-select : none;">

<head>

<meta charset="utf-8">

<title>oto 7 - MONKEY CIRCUS おさるサーカス</title>
<meta property="og:title" content="oto 7 - MONKEY CIRCUS おさるサーカス">
<meta property="og:url" content="https://funagoro.github.io/experiment/glsl/oto_7/oto_7.html">
<meta property="og:type" content="website">
<meta property="og:image" content="https://funagoro.github.io/experiment/glsl/oto_7/oto_7_t.jpg">
<link rel="apple-touch-icon" href="https://funagoro.github.io/experiment/glsl/oto_7/oto_7_t.jpg">
<meta name="apple-mobile-web-app-title" content="oto 7">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="description" content="AudioWorklet experiment with GLSL WebGL">

<link rel="shortcut icon" href="favicon.ico" />
<link rel="stylesheet" type="text/css" href="glsl.css" />

<meta name="viewport" content="width=600">
<style> @viewport { width : 600px;} </style>

</head>

<body>



<div class="t"></div>



<canvas id="canvas_1" style="
	width : 512px; height : 512px;
	user-select : none;
	-webkit-tap-highlight-color : rgba( 0, 0, 0, 0);
	touch-action : none;
"></canvas><br>
<span id="span_1">- - - - -</span><br>
<span class="title">"oto 7" 実験中。</span><br>
&copy;2022 Maeda Mameo<br>



<div class="b"></div>



<script src="oto_7_jpg_b64.js"></script>
<script src="skeleton_touch_2.js"></script>

<script src="three_130_min.js"></script>

<script>

'use strict';

const W = 512;
let i;
let t;
let o;

const STATE_DEFAULT = 0, STATE_INIT = 1, STATE_WORKING = 2, STATE_MUTED = 3;
let current_state = STATE_DEFAULT, next_state = STATE_DEFAULT;

const can = document.getElementById( "canvas_1");
can.width = can.height = W;

const ren = new THREE.WebGLRenderer( { canvas : can});
ren.shadowMap.enabled = true;
ren.shadowMap.type = THREE.PCFSoftShadowMap;

const cam = new THREE.PerspectiveCamera( 35, W / W, 0.1, 10);

const scene = new THREE.Scene();
scene.background = new THREE.Color( 0);
scene.fog = new THREE.Fog( scene.background, 5, 9);

//★ TAP TO PLAY AUDIO の文字。
const ld = new THREE.TextureLoader();
const tex_touch = ld.load( "data:;base64," +
`R0lGODlhgAAIAIAAAAAAAP///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlk
PSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpu
czptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNy4xLWMwMDAgNzkuZWRhMmIzZmFjLCAy
MDIxLzExLzE3LTE3OjIzOjE5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93
d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJk
ZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5z
OnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0
cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JU
b29sPSJBZG9iZSBQaG90b3Nob3AgMjMuMSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0i
eG1wLmlpZDpFRUMyQzdGOUIyREExMUVDQkQxREJDRDMwQkNFOEQwQiIgeG1wTU06RG9jdW1lbnRJ
RD0ieG1wLmRpZDpFRUMyQzdGQUIyREExMUVDQkQxREJDRDMwQkNFOEQwQiI+IDx4bXBNTTpEZXJp
dmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkVFQzJDN0Y3QjJEQTExRUNCRDFEQkNE
MzBCQ0U4RDBCIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVFQzJDN0Y4QjJEQTExRUNCRDFE
QkNEMzBCQ0U4RDBCIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRh
PiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d
3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWk
o6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxr
amloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMy
MTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAAAA
AAAsAAAAAIAACAAAAoWED6Eb6A+jnLTa+9plC/GjgJ04JhqpnaJxqiYIm2r5SqHluonH9n7sm8Fy
vRZvh0SmjkFbckJ0GJu/n9D6nDauytg0yZVWI1HmR6b7gkczBpDlBmPnYy/0JssAl+RjOLsnRtUF
aJeBZ4NHEzio51EGF/JV1qKISINIgtOG0en5CQqa6VAAADs=`);
tex_touch.magFilter = THREE.NearestFilter;
o = new THREE.Mesh(
	new THREE.PlaneGeometry( 128, 8),
	new THREE.MeshBasicMaterial( { color : 0x999999, transparent : true, blending : THREE.SubtractiveBlending, map : tex_touch})
);
o.position.z = 0.001;
const o_tap = new THREE.Mesh(
	new THREE.PlaneGeometry( 150, 150),
	new THREE.MeshBasicMaterial( { color : 0xffffff, transparent : true, opacity : 0.7})
);
o_tap.add( o);
t = 0.006;
o_tap.scale.set( t, t, t);
o_tap.rotation.x = -0.785;
o_tap.rotation.order = "YXZ"; //★ ← ここ大事。
scene.add( o_tap);

const tex = ld.load( "data:;base64," + oto_7_jpg_b64);
const plane = new THREE.Mesh(
	new THREE.PlaneGeometry( 2, 2),
	new THREE.MeshBasicMaterial( { map : tex})
);
plane.rotation.x = -0.785;
plane.rotation.order = "YXZ"; //★ ← ここ大事。
scene.add( plane);

//★ 大きいボール。
const ball = new THREE.Mesh(
	new THREE.SphereBufferGeometry( 1, 40, 20),
	new THREE.MeshPhongMaterial( { color : 0xffffff})
);
ball.castShadow = true;
scene.add( ball);

//★ 小さいボール。
const balls = new Array( 5);
balls[ 0] = ball.clone();
t = 0.5;
balls[ 0].scale.set( t, t, t);
for( i = 1; i < 5; i++) balls[ i] = balls[ 0].clone();
for( i = 0; i < 5; i++) scene.add( balls[ i]);

//★ 床。
o = new THREE.Mesh(
	new THREE.PlaneGeometry( 5, 5),
	new THREE.MeshPhongMaterial( { color : 0xffffff})
);
o.receiveShadow = true;
o.rotation.x = -1.5708;
scene.add( o);

//★ 赤いライト。
o = new THREE.SpotLight( 0xff0000, 5, 30, 1, 1.5, 3); //★ 色, 強さ, 距離, 拡がり, ボケ, 減衰。
o.castShadow = true;
o.position.set( 3, 4, -5);
scene.add( o);

//★ 緑のライト。
o = o.clone();
o.color.set( 0x00ff00);
o.position.set( -3, 4, -5);
scene.add( o);

//★ 青いライト。
o = o.clone();
o.angle = 0.6;
o.color.set( 0x0000ff);
o.position.set( 0, 4, 2);
scene.add( o);

//◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍

let is_visibility_listener = false;
let ac;
let awnode;
let absn;

//★ skeleton_touch.js のための設定。
const REFW = W, REFH = W, MAXTOUCH = 5, CAN_PINCH = false;
function touch_event_hook(){
	if( skt.can_ios_audio_start){
		if( current_state == STATE_DEFAULT){
			init_ac();
		} else if( current_state == STATE_MUTED){
			//ac.resume();
			//★ ac.suspend() して、他のアプリで遊んだ後、ac.resume() しても、
			//★ 音が出ない場合があるので、ac.close() して、次回は new する。
			init_ac();
		}
		function init_ac(){
			ac = new window.AudioContext();
			ac.createBufferSource().start(); //★ こんなダミーでもいいので、再生する必要がある。
			ac.audioWorklet.addModule( "data:text/javascript," + encodeURI( `

				'use strict';

				class awp extends AudioWorkletProcessor{
					constructor(){
						let that;

						super();

						this.s = 0;
						this.p = 0;
						that = this;

						this.port.onmessage = function( e){
							that.s = Math.floor( 1000000 * parseFloat( e.data) / sampleRate);
						}

						//★ こちらのスレッドでは console.log() ができないので、デバグ情報などは、文字列としてメインスレッドに送る。
						this.port.postMessage( "hello!");
					}

					process( inputs, outputs, parameters){
						let i, n;

						const o = outputs[ 0];
						//const channel_num = o.length;
						const d0 = o[ 0];
						const d1 = o[ 1];

						n = d0.length;
						for( i = 0; i < n; i++){
							d0[ i] = 0.03 * Math.sin( 6.28318 * 0.000001 * this.p);
							this.p = ( this.p + this.s) % 1000000;

							//d1[ i] = -d0[ i];
						}

						return true;
					}
				}

				registerProcessor( "awp_name", awp);

			`)).then( function(){
				awnode = new AudioWorkletNode( ac, "awp_name", { outputChannelCount : [ 2]}); //★ ステレオにする。
//console.log( awnode.numberOfOutputs);
				awnode.connect( ac.destination);
				awnode.port.onmessage = function( e){ console.log( e.data);}

				o_tap.visible = false;
				current_state = next_state = STATE_INIT;
				count = 0;
			}).catch( console.error);

			if( !is_visibility_listener){ //★ 何重にもリスナを登録してはいけない。
				document.addEventListener( "visibilitychange", function(){
					let s;

					s = document.visibilityState;
					if( s == "hidden"){
						if( ac.state != "closed"){ //★ すでに closed の時に、close() してはいけない。
							//ac.suspend();

							//★ ac.suspend() ではなく、ac.close()
							ac.close();
							o_tap.visible = true;
							current_state = next_state = STATE_MUTED;
							count = 0;
						}
					} else if( s == "visible"){
						//★ タッチで再開するので、ここでは何もしない。
					}
				}, false);

				is_visibility_listener = true;
			}
		}
	}
}
const skt = new skeleton_touch( can);
skt.set_mag_and_orientation( 1, 0);

//◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍

let ab_kick, gn_kick;
let ab_bass, gn_bass;
let ab_saw, gn_saw;
let ab_hihat, gn_hihat;
let ab_metal, gn_metal;
let ab_beam, gn_beam;

let count = 0;

tic();

function tic(){
	let i, j;
	let a, b, t;

	requestAnimationFrame( tic);

	skt.pre();

	if( ac){
		if( count % 20 == 0) document.getElementById( "span_1").innerHTML = ac.state;
		if( current_state == STATE_WORKING && ( ac.state == "suspended" || ac.state == "interrupted")){
			//★ 電話の着信などで、visibility が hidden になることなく、中断された後、戻ってきた時。
			ac.close();
			o_tap.visible = true;
			next_state = STATE_MUTED;
		}
	}

	a = Math.sin( count % 40 / 40 * 3.14159);
	b = Math.sin( count % 15 / 15 * 3.14159);

	if( current_state == STATE_INIT){
		if( count == 0){
			let n, r;
			let t, w;
			let d, d1;

const BPM = 180;
			r = ac.sampleRate;

function mod( x, y){ return x - y * Math.floor( x / y);}

function texrnd( x, y){
	let a;

	a = Math.sin( 12.9898 * x + 78.233 * y) * 43758.5453;
	return a - Math.floor( a);
}

			//★ kick。
			n = Math.floor( 60 / BPM * r);
			ab_kick = ac.createBuffer( 2, n, r); //★ チャンネル数、サンプル数、レート。
			d = ab_kick.getChannelData( 0);
			d1 = ab_kick.getChannelData( 1);
			for( i = 0; i < n; i++){
				t = i / r % ( 60 / BPM);
				d[ i] = 0.5 * Math.max( Math.min(
					Math.exp( -10 * t) * Math.sin( 6.28318 * (
						50 * t - 6 * (
							Math.exp( -10 * t) +
							Math.exp( -80 * t) +
							Math.exp( -400 * t)
						)
					))
				, 1), 0);
				d1[ i] = d[ i];
			}
			gn_kick = ac.createGain();
			gn_kick.gain.value = 1;
			gn_kick.connect( ac.destination);

			//★ bass。
			n = Math.floor( 0.25 * 60 / BPM * r);
			ab_bass = ac.createBuffer( 2, n, r); //★ チャンネル数、サンプル数、レート。
			d = ab_bass.getChannelData( 0);
			d1 = ab_bass.getChannelData( 1);
			for( i = 0; i < n; i++){
				t = i / r % ( 0.25 * 60 / BPM);
				a = Math.exp( -20.0 * t);
				let cutoff = 100.0 + 400 * a;
				let freq = ( 440.0 * Math.pow( 2, -38 / 12));
				b = filterSaw( freq, t + 0.004 * Math.sin( 4 * 3.14159 * freq * t), cutoff, 1, -1);
				d[ i] += a * b;
				b = filterSaw( freq, t + 0.004 * Math.sin( 4 * 3.14159 * freq * t), cutoff, 1, 1);
				d1[ i] += a * b;
			}
			gn_bass = ac.createGain();
			gn_bass.connect( ac.destination);

			ab_saw = new Array( 20);
			for( i = 0; i < 20; i++){
				n = Math.floor( 0.25 * 60 / BPM * r);
				ab_saw[ i] = ac.createBuffer( 2, n, r); //★ チャンネル数、サンプル数、レート。
				d = ab_saw[ i].getChannelData( 0);
				d1 = ab_saw[ i].getChannelData( 1);
				for( j = 0; j < n; j++){
					t = j / r % ( 0.25 * 60 / BPM);
					//let begin = j / r - t;
					let begin = i / 20;
					let dice = texrnd( 256 * 0.741 * begin, 256 * 0.891 * begin);
					if( t < ( 0.25 - dice * 0.2) * 60 / BPM){
						let freq = 20 * Math.sin( 4 * 3.14159 * begin);
						a = 2 * mod( 20 * Math.exp( -2 * mod( 10 * Math.exp( -freq * t), 1)), 1) - 1;
						d[ j] = d1[ j] = a;
					}
				}
			}
			gn_saw = ac.createGain();
			gn_saw.gain.value = 0.1;
			gn_saw.connect( ac.destination);

			//★ hihat。
			n = Math.floor( 0.25 * 60 / BPM * r);
			ab_hihat = ac.createBuffer( 2, n, r); //★ チャンネル数、サンプル数、レート。
			d = ab_hihat.getChannelData( 0);
			d1 = ab_hihat.getChannelData( 1);
			for( i = 0; i < n; i++){
				t = mod( i / r, 0.25 * 60 / BPM);
				a = Math.floor( i / r / ( 0.25 * 60 / BPM));
				let open = 30 + 170 * texrnd( 0.741 * a, 0.891 * a);
				a = Math.exp( -open * t);
				b = wavetable( 20, t, 4, 0, 0);
				d[ i] += a * b;

				b = wavetable( 20, t, 4, 0, 256);
				d1[ i] += a * b;
			}
			gn_hihat = ac.createGain();
			gn_hihat.gain.value = 0.3;
			gn_hihat.connect( ac.destination);

			//★ metal。
			n = Math.floor( 0.25 * 60 / BPM * r);
			ab_metal = ac.createBuffer( 2, n, r); //★ チャンネル数、サンプル数、レート。
			d = ab_metal.getChannelData( 0);
			d1 = ab_metal.getChannelData( 1);
			for( i = 0; i < n; i++){
				t = i / r;
				a = 0.3 * Math.exp( -30 * t);
				b = wavetable( 100, t, 0.8, 0, 0);
				d[ i] += a * b;

				b = wavetable( 100, t, 0.8, 0, 256);
				d1[ i] += a * b;
			}
			gn_metal = ac.createGain();
			gn_metal.gain.value = 1;
			gn_metal.connect( ac.destination);

			//★ beam。
			n = Math.floor( 0.5 * 60 / BPM * r);
			ab_beam = ac.createBuffer( 2, n, r); //★ チャンネル数、サンプル数、レート。
			d = ab_beam.getChannelData( 0);
			d1 = ab_beam.getChannelData( 1);
			for( i = 0; i < n; i++){
				t = i / r;
				a = 0.1 + 0.2 * Math.exp( -30.0 * t);
				b = wavetable( 14, t, 2, 0, 0);
				d[ i] += a * b;

				b = wavetable( 14, t, 2, 0, 256);
				d1[ i] += a * b;
			}
			gn_beam = ac.createGain();
			gn_beam.gain.value = 1;
			gn_beam.connect( ac.destination);

function smoothstep( a, b, c){
	let t = Math.max( Math.min( ( c - a) / ( b - a), 1), 0);
	return t * t * ( 3 - 2 * t);
}

function tri( p){ return 1 - 4 * Math.abs( mod( p, 1) - 0.5);}

function wavetable( freq, time, speed, offset, y){
	if( time < 0) return 0;
	let p = tri( freq * time);
	let t = p * speed + offset;
	return 1.0 - 2.0 * texrnd( Math.floor( 256 * 0.741 * t), y + Math.floor( 256 * 0.891 * t));
}

function filterSaw( freq, time, cutoff, resonance, c){
	let i;
	if( time < 0) return 0;
	let sum = 0;
	for( let i = 1; i <= 32; i++){
		let cut = smoothstep( cutoff * 1.2, cutoff * 0.8, i * freq );
		cut += smoothstep( cutoff * 0.3, 0.0, Math.abs( cutoff - i * freq ) ) * resonance;
		let offset = c * 0.1 * ( i - 1.0);
		sum += Math.sin( 6.28318 * i * freq * time + offset ) / i * cut;
	}
	return sum;
}

		} else{
			if( ac.state != "suspended"){
				next_state = STATE_WORKING;
			}
		}
	} else if( current_state == STATE_WORKING){
		awnode.port.postMessage( 880 * Math.pow( 2, b));

		if( skt.start || count % 40 < 0){
			absn = ac.createBufferSource();
			absn.buffer = ab_bass;
			absn.connect( gn_bass);
			absn.start();
		}

		if( count % 20 == 0){
			absn = ac.createBufferSource();
			absn.buffer = ab_kick;
			absn.connect( gn_kick);
			absn.start();
		}

		if( count % 5 == 0){
			gn_bass.gain.value = 0.4 * Math.min( count % 20 * 1.6 / 20, 1);
			absn = ac.createBufferSource();
			absn.buffer = ab_bass;
			absn.connect( gn_bass);
			absn.start();

			absn = ac.createBufferSource();
			absn.buffer = ab_saw[ Math.floor( 20 * Math.random())];
			absn.connect( gn_saw);
			absn.start();

			absn = ac.createBufferSource();
			absn.buffer = ab_hihat;
			absn.connect( gn_hihat);
			absn.start();
		}

		if( count % 20 == 10){
			absn = ac.createBufferSource();
			absn.buffer = ab_metal;
			absn.connect( gn_metal);
			absn.start();
		}

		if( count % 40 == 20){
			absn = ac.createBufferSource();
			absn.buffer = ab_beam;
			absn.connect( gn_beam);
			absn.start();
		}
	}

	ball.position.y = 0.5 + 0.7 * a;

	for( i = 0; i < 5; i++){
		t = 2 * 3.14159 * ( count % 200 + 40 * i) / 200;
		balls[ i].position.set( 2 * Math.sin( t), 0.25 + 0.15 * b, 2 * Math.cos( t));
	}

	t = 2 * 3.14159 * ( count % 300 / 300);
	cam.position.set( 5 * Math.sin( t), 5, 5 * Math.cos( t));
	cam.lookAt( 0, 0, 0);

	if( o_tap.visible){
		o_tap.position.set( 4 * Math.sin( t), 4, 4 * Math.cos( t));
		o_tap.rotation.y = t;
	}

	plane.position.set( 3.9 * Math.sin( t), 3.9, 3.9 * Math.cos( t));
	plane.rotation.y = t;
	t = count % 20;
	t = 0.5 * ( 1.2 - 0.01 * t);
	plane.scale.set( t, t, t);

	ren.render( scene, cam);

	skt.post();

	if( current_state != next_state){
		current_state = next_state;
		count = 0;
	} else count++;
}
</script>

</body>

</html>
